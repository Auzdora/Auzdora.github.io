<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CMU 15-445 Buffer Pool Manager</title>
      <link href="/2023/04/01/Buffer_Pool_Manager/"/>
      <url>/2023/04/01/Buffer_Pool_Manager/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Buffer Pool Manager Instance这个Task本质而言就是理解清楚Extendible Hash Table和LRU-K Replacer的关系，然后将它们组合起来。实现的难度并不高，只要按照注释内容好好分析，然后按逻辑写下来就可以。重点在于每一个操作的细节问题，细节问题很多，要时刻注意。</p></blockquote><h2 id="Buffer-Pool-Manager-Mechanism"><a href="#Buffer-Pool-Manager-Mechanism" class="headerlink" title="Buffer Pool Manager Mechanism"></a>Buffer Pool Manager Mechanism</h2><p>想要实现Buffer Pool Manager，我们就要在high-level的角度理解一下Buffer Pool Manager在系统中的作用。先看下图：</p><p><img src="/2023/04/01/Buffer_Pool_Manager/bpm1.png"></p><p>站在System的角度看，System会向Buffer Pool Manager发送一个请求，指定一个page id，Buffer Pool Manager返回这个page在内存中的地址（或者新建一个page）。仅此而已，系统只需要关心要那个page，并等待Buffer Pool Manager返回即可。</p><p>接下来我们去BPM内部看一下。当System想要Fetch一个page时，为了快速在内存中找到指定page id的位置，这里用了Extendible Hash Table。根据之前实现的Hash Table，执行Find操作，将对应的位置，也就是frame id查询出来（<strong>因为Buffer Pool Manager在内存中创建page slot的时候是以数组的形式创建的，因此frame id对应的就是数组的下标索引</strong>）。接着我们可以在内存中找到，并返回page的地址即可。</p><p>如果Fetch操作在哈希表中没找到对应的frame id，说明内存中并不存在这个page。接下来做的操作，就是想从Disk中将对应page的数据copy进来，同时在内存中给它找到一席之地。</p><p>从上图的Buffer Pool中可以看到，内存中灰色的page表示的是当前没有存放page的内存块。因此想从Disk中复制数据进来时，我们就可以先看看Free List中有无空闲的空间。如果有，就采用这个对应的frame id。如果没有，说明内存中所有的page全都放满了，那么就需要从LRU-K Replacer中，选取一个适合驱逐的内存块驱逐它，留出位置给从Disk copy的page使用。</p><h2 id="Buffer-Pool-Manager-Instance-Implementation"><a href="#Buffer-Pool-Manager-Instance-Implementation" class="headerlink" title="Buffer Pool Manager Instance Implementation"></a>Buffer Pool Manager Instance Implementation</h2><p>相关文件夹提供了API及其注释，分别有<code>NewPgImp</code>、<code>FetchPgImp</code>、<code>UnpinPgImp</code>、<code>FlushPgImp</code>、<code>FlushAllPgsImp</code>以及<code>DeletePgImp</code>需要我们实现。相关实现需要注意的地方注释中写的很清晰，当然还有很多细节部分注释中并没有标注出来。比如哈希表的增加和删除的时机、pin count增加的时机等等，这些都是需要自己去debug过程中发现代码漏洞而去补全的。</p><p>这里主要说明一下数据结构部分。<code>pages_</code>是一个page数组的首地址，既然是数组，那说明它们的内存空间是连续的，而且支持随机查找。<code>pages_</code>的索引就是frame id，表明这是buffer pool中第几个slot。<code>disk_manager_</code>我们只需要用到其中的<code>WritePage</code>和<code>ReadPage</code>的API即可。<code>page_table_</code>实现的是page id到frame id的映射关系，使得对指定page id的查找时间复杂度从O(N)降到了O(1)。使用这个数据结构的时候，要注意删除一个page时随即删除<code>page_table_</code>的相关记录，不然之后会导致读到的page的内容是不同page id内容的情况。<code>replacer_</code>的作用是，如果当前buffer pool全部满了，提供一个可驱逐的frame id号，buffer pool manager会根据这个frame id对这块内存进行驱逐，再把想要的page从Disk拷贝到这块内存中。</p><p>关于线程安全，我还是一把大锁锁住所有，尝试过优化，但并没有明显的效果。Leaderboard的结果在2.1s左右。希望各位大佬能对优化方案提供一些建议。</p><p>附一张截图：</p><p><img src="/2023/04/01/Buffer_Pool_Manager/bpm2.png"></p><h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><ul><li><code>FlushPgImp</code>并不是要将指定page重写回disk并刷新这块内存空间的意思，单纯就是为了将这page写会Disk刷新一下，不改变其在内存中的状态。<code>FlushAllPgsImp</code>同理。</li><li>每次<code>FetchPgImp</code>，就要增加指定page中的pin count。</li><li>Evict和Remove一个page之后，不要忘记<code>ResetMemory</code>。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 LRU-K Replacement Policy</title>
      <link href="/2023/03/26/LRU-K_Replacement_Policy/"/>
      <url>/2023/03/26/LRU-K_Replacement_Policy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实现LRU-K的时候，先去完成了LeetCode的146题LRU，实现的时候运用了哈希链表结构，题目中要求get和put操作都是O(1)的时间复杂度。一种实现方式就是用STL的list和unordered map，list本质是双向链表，但实现出来最后的结果总是不尽人意。因此将list结构换成自己实现的双向链表，运行起来的速度和内存都优于list的实现。因此在15-445的LRU的实现中，我也采用了自己实现的一个内嵌结构体作为双向链表的基础。总体而言，参考了网上对于LRU-K的讲解之后，对LRU-K的算法操作还是比较清晰的，不像Extendible Hash Table那样一知半解。所以实现起来也很清晰。但由于用的是自己写的双向链表，debug花时间最久的就是内存泄漏问题，因为之前写过的一些项目都没有考虑，因此花了很长时间去定位错误。总体来说是一个教训。</p></blockquote><h2 id="Replacement-Policy"><a href="#Replacement-Policy" class="headerlink" title="Replacement Policy"></a>Replacement Policy</h2><p>缓存驱逐算法的应用场景是，由于内存和硬盘之间读写速度的巨大差异，并且有程序局部性原理的存在，我们想通过<strong>保存从硬盘中读取出的东西在内存中</strong>，这样一种方法来尽可能减少两者之间速度的差异，提高CPU的利用率和处理速度，减少不必要的等待时间。从硬盘中读取出的数据一定是换存在内存中的，而由于内存的大小局限性，我们不可能无限的存储硬盘的page，甚至只能分配内存的一小部分作为缓存空间来使用。</p><p>这样的缓存空间一定是有大小的，有大小就会涉及到缓存存满的问题。如果想要再存放新读入的数据到缓存空间中，必须选择一个内存块将其驱逐出去。把空间给腾出来。选择哪一块驱逐，就是替换算法（replacement policy）所做的事情。一般常见的替换策略有FIFO，LRU以及LFU等等。</p><p>下图展现了硬盘数据和内存之间提取（Fetch）和驱逐（Evict）的关系。</p><p><img src="/2023/03/26/LRU-K_Replacement_Policy/lruk1.png"></p><p>上面图片中，Buffer Pool就是缓存数据的池子，最大容量为3个page。Disk上面的Data数不胜数，当需要数据时系统会从Buffer Pool检索，如果检索到了，则直接从内存中提出数据，并且通知<strong>LRU-K Replacement Policy</strong>组件调用了这个page。如果没检索到，就从硬盘中读取一块。如果此时Buffer Pool满了，那就询问<strong>LRU-K Replacement Policy</strong>组件，索要一个可以驱逐的frame id号，系统再根据这个frame id从内存中把对应的page重新写回硬盘（<strong>NOTE：LRU-K不做任何实际的数据操作，仅仅是记录frame的状态，并根据一定的策略将可以驱逐的frame id号提供给系统</strong>）。</p><h2 id="LRU-and-LRU-K"><a href="#LRU-and-LRU-K" class="headerlink" title="LRU and LRU-K"></a>LRU and LRU-K</h2><p>建议还是去做一下力扣146题，通过这道题可以了解LRU的算法流程。LRU其实很简单，用语言表述一句话就是：选择最长时间不访问的page驱逐。话是这么说，实现上还是需要一些技巧的。题目中需要实现两个方法，一个是get一个是put。put是给定一个key，value，将其存入链表中。get操作是给定key，返回一个key对应的value，并删除对应的key&#x2F;value pair。题目要求两个操作的时间复杂度为O(1)。</p><p>链表的插入和删除操作的复杂度为O(1)，但是查找的时间复杂度为O(N)。这就没办法满足get操作的要求。我第一次实现的时候直接用了C++的list容器，结果最后超时了。如果查找满足时间复杂度为O(1)，就需要用哈希数据结构。但哈希表是无序结构，LRU需要有序结构。结合两者的优点，就是哈希链表。查找时索引哈希表，得到对应链表的地址，插入和删除时直接用双向链表的删除即可。</p><p>用例子来理解一下LRU的算法。假设LRU最大存储量为3，接下来对算法进行put(1, 1), put(2, 2), put(3, 3), get(2, 2), put(1, 2)的操作。看下图的操作顺序（<strong>我实现的方式是，链表头是要驱逐的元素，链表尾部是最新使用过的元素</strong>）。</p><p><img src="/2023/03/26/LRU-K_Replacement_Policy/lruk2.png"></p><p>当然这只是双向链表的视角，别忘了，为了实现O(1)的get操作，我们还有一个哈希结构。下面是一个哈希链表结构的示意图。</p><p><img src="/2023/03/26/LRU-K_Replacement_Policy/lruk3.png"></p><p>新增的头节点L和尾节点R可以用来直接对头部和尾部进行操作，头部要移除，尾部要插入，就不必去寻找头尾节点了。这两个头尾节点在之后的LRU-K算法实现中会扩展成头部、中间和尾部节点，关于这部分之后在叙述我的想法。</p><p>Leetcode的代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> key_;</span><br><span class="line">        <span class="type">int</span> val_;</span><br><span class="line">        Node* left = <span class="literal">nullptr</span>;</span><br><span class="line">        Node* right = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> k, <span class="type">int</span> v) : <span class="built_in">key_</span>(k), <span class="built_in">val_</span>(v), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity_;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, Node*&gt; cache_map_;</span><br><span class="line">    Node *R;</span><br><span class="line">    Node *L;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">capacity_</span>(capacity) &#123;</span><br><span class="line">        R = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        L = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        R-&gt;right = L;</span><br><span class="line">        R-&gt;left = L;</span><br><span class="line">        L-&gt;right = R;</span><br><span class="line">        L-&gt;left = R;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertNode</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// insert to back of list</span></span><br><span class="line">        node-&gt;left = R-&gt;left;</span><br><span class="line">        node-&gt;right = R;</span><br><span class="line">        R-&gt;left-&gt;right = node;</span><br><span class="line">        R-&gt;left = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveNodeToBack</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">eraseNode</span>(node);</span><br><span class="line">        <span class="built_in">insertNode</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eraseNode</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">        node-&gt;left-&gt;right = node-&gt;right;</span><br><span class="line">        node-&gt;right-&gt;left = node-&gt;left;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = cache_map_.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != cache_map_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="built_in">moveNodeToBack</span>(it-&gt;second);</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second-&gt;val_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = cache_map_.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != cache_map_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            it-&gt;second-&gt;val_ = value;</span><br><span class="line">            <span class="built_in">moveNodeToBack</span>(it-&gt;second);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (size == capacity_) &#123;</span><br><span class="line">            cache_map_.<span class="built_in">erase</span>(L-&gt;right-&gt;key_);</span><br><span class="line">            <span class="built_in">eraseNode</span>(L-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">        <span class="built_in">insertNode</span>(node);</span><br><span class="line">        cache_map_[key] = node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>LRU-K算法是LRU算法的改进版。LRU算法存在的问题是，当存在大量的一次性操作时，会把历史的缓存冲刷掉，而新进入buffer pool的page有可能之后不会再访问了，被冲刷掉的page是之前保留下来的比较“有用”的page，这就是<strong>缓存污染</strong>问题。</p><p>LRU-K的思路是，永远最先驱逐访问次数小于K次的page。网上的很多讲解是直接维护两个链表，一个叫做history list，另一个叫buffer list。新加入的page总会先进入history list，当访问次数等于指定的次数K次时，就会从history list删除，并移动到buffer list的尾部（<strong>这里还是假设尾部的page是最新使用的，头部page是最近最久未使用的</strong>）。</p><p>通过例子来理解一下这个LRU-K算法，首先插入key&#x3D;1，2，3，它们的value分别是1，1，1。原因是这里的value我用它来记录K的次数，也就是访问的次数。现在假设整个history list和buffer list最多存储三个page，就是buffer pool的大小，且K&#x3D;2。首先我们访问key&#x3D;1的page，那么对应的node的value就会变为2，一旦等于了K的值，说明这个page是可能被经常访问的，就把它移入buffer list。</p><p><img src="/2023/03/26/LRU-K_Replacement_Policy/lruk4.png"></p><p>接着我们再访问key&#x3D;2的page。</p><p><img src="/2023/03/26/LRU-K_Replacement_Policy/lruk5.png"></p><p>Buffer list服从LRU算法，History List可以服从任意替换算法，在实验手册中，要求驱逐最早进入history list的page，采用的是FIFO策略（<strong>刚开始我实现的history list是LRU策略，结果会导致Evict Test无法通过，一定要注意history和buffer的策略不一样</strong>）。</p><p>接着我们尝试插入key&#x3D;4的page，结果发现buffer pool满了（总共的空间为3，history占1，buffer占2），那么就需要对某一个page进行缓存驱逐，根据原则：<strong>永远最先驱逐访问次数小于K的page</strong>。所以先驱逐掉3，再加4到history list中。</p><p><img src="/2023/03/26/LRU-K_Replacement_Policy/lruk6.png"></p><p>History list采用FIFO，由于History list只剩下3了，那么只能驱逐3。如果继续访问4，那么4会被移入Buffer list中，此时buffer pool也已经满了。如果想再插入一个新的page，需要缓存驱逐，这时就要从buffer list里面根据LRU算法进行驱逐了，具体的例子可以自行画一下。</p><p>以上就是LRU和LRU-K算法的解释。</p><h2 id="LRU-K-Implementation"><a href="#LRU-K-Implementation" class="headerlink" title="LRU-K Implementation"></a>LRU-K Implementation</h2><p>实现15-445 LRU-K任务的时候，我采用的还是使用自己定义的结构体Node和STL的unordered_map结构，实现哈希链表。链表不使用STL的list的一个原因是Leetcode跑下来的结果优于使用STL的list，性能方面会更好；另一个原因就是结构体定义数据和操作的自由度高，可以根据自己的想法来实现。缺点就是，<strong>要注意内存泄漏问题（由于之前经验很少，此处debug时间花的很多）</strong>。</p><p>实现思路总体继承Leetcode的解法，定义一个有key，value，左右指针的节点，同时为了区分每一个节点是否evictable，加如了一个bool变量。其中，key存储对应的frame_id，value代表被访问的次数，evictable表示这个节点是否可以被驱逐。</p><p>设计双链表的时候，除去左节点L和右节点R，我还加入了一个中间节点M，作为history list和buffer list的分割节点。两种list连接在一条双向链表上，再用unordered map索引。</p><p>具体的效果如下图：</p><p><img src="/2023/03/26/LRU-K_Replacement_Policy/lruk7.png"></p><p>然后对history list和buffer list分别维护一个计数器，计算当前包含的节点数量，可用来判断是否需要驱逐缓存（注意需要迭代判断，并不能直接取L节点或M节点的下一个，因为下一个节点很有可能是non-evictable的）。</p><p>线程安全方面是直接一把大锁锁住所有操作。并没有细致的对每一个结构进行优化。</p><h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><ul><li><p>最主要的问题就是内存泄漏问题，真的是种种内存泄漏。最大的原因就是，程序结束之后，有一些内存中的节点，没有被人为的Remove或者Evict，导致结束程序后将这些节点遗留下来，造成的内存泄漏。解决方案就是在Replacer的析构函数里实现一个强制去除当前链表所有节点的程序（包括non-evictable，因为之前实现的是直接循环Evict，再删除L，M和R，但总还是有内存泄漏问题，原因在于Evict仅仅驱逐evictable数据，析构函数调用它会删不干净）。还有的内存泄漏问题就是use after free问题。这个问题值得是在释放内存空间后还尝试使用这个内存空间。经典出现的地方在于，删除节点的时候要伴随哈希表对应数据的删除。需要注意的是哈希表的<code>erase</code>方法：如果用key删除，且value存储的是指针，那么仅仅会删掉哈希表中的数据，指针所指向的内存是不会被删除的；如果用迭代器删除，我们首先应当删除迭代器的second所指向的内存空间，然后再删除迭代器的first对应的key。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash_map_&lt;int, Node*&gt;</span></span><br><span class="line"><span class="keyword">auto</span> it = hash_map_.<span class="built_in">find</span>(frame_id)；</span><br><span class="line">hash_map_.<span class="built_in">erase</span>(it-&gt;first);</span><br><span class="line"><span class="built_in">EraseNode</span>(it-&gt;second); <span class="comment">// 报错use after free，因为已经删除了对应的数据，迭代器不可用，it无法索引到</span></span><br><span class="line"></span><br><span class="line">Node *p = L-&gt;right; <span class="comment">// 取出头节点</span></span><br><span class="line">hash_map_.<span class="built_in">erase</span>(p-&gt;key)；</span><br><span class="line"><span class="built_in">EraseNode</span>(p)； <span class="comment">// 成功，因为hash map只删除了表中存储的数据，原Node内存还存在</span></span><br></pre></td></tr></table></figure></li><li><p>History list用的是FIFO，Buffer list采用LRU。我开始都用的LRU，导致EvictTest报错。</p></li><li><p>注意要实现自己的双向链表的删除，插入和移动的相关函数。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 Extendible Hash Table</title>
      <link href="/2023/03/22/Extendible_Hash_Table/"/>
      <url>/2023/03/22/Extendible_Hash_Table/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在学习CMU的15-445 DB课程，在做Project1的Extendible Hash Table的时候，由于是先看了课程，过了一个多星期才做的Lab，对extendible hash table只能说是知道大体的意思，并没有透彻的了解它，尤其是bucket指针和数据重分配这一部分，涉及到比较tricky的位运算，在一知半解的情况下实现它，完全没办法找到对应的bug，ConcurrentInsertFindTest和GetNumBucketsTest总是fail。又去参考了很多对可扩展哈希的文章，才发现自己一些细节是错误的。本篇文章尝试以我的理解说清楚extendible hash table，并作为我的菜坑记录。</p></blockquote><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>这一部分的任务就是搭建一个通用的存储unique KV对的哈希表。我们需要实现哈希表的插入、删除以及查找操作。实验手册中并没有要求我们实现shrink部分，所以只需要关注如何扩展哈希表即可。代码在<code>scr/include/container/hash/extendible_hash_table.h</code>以及 <code>extendible_hash_table.cpp</code>下，实现之前建议先阅读这两个文件的代码和注释，明确我们的目标。</p><h2 id="Overview-of-Extendible-Hash-Table"><a href="#Overview-of-Extendible-Hash-Table" class="headerlink" title="Overview of Extendible Hash Table"></a>Overview of Extendible Hash Table</h2><p>在理解可扩展哈希表之前，我们需要了解几个概念。</p><ul><li><strong>Directory</strong>：是存放bucket指针的容器，可动态生长（以原大小的倍数作为增长率），容器的每个元素可用哈希值来索引。</li><li><strong>Bucket</strong>：桶。存放Key&#x2F;value pair的桶，数据结构层面是一个线性表。</li></ul><p>下面是一个简单的可扩展哈希表的示意图，具体不用关心它是怎么来的，先对它建立一个直观的印象即可。</p><p><img src="/2023/03/22/Extendible_Hash_Table/eht1.png"></p><p>上图又出现两个概念：</p><ul><li><strong>Global Depth</strong>：假设global depth为n，那么当前的directory必定有$2^n$个entry。例如，当前$n&#x3D;2$，那么就有4个entry，$n&#x3D;3$就有8个entry。同时，给定一个key，需要用global depth取出这个key的低n位的二进制值。例如，一个key的二进制是10111，如果global depth是3，通过<code>IndexOf(key)</code>函数，得到返回值的二进制值是111，即为7。这个值用来索引directory[111]位置的bucket。</li><li><strong>Local Depth</strong>：local depth指的是（假设local depth为n），在当前的bucket之下，每个元素的key的低n位都是相同的。</li></ul><p>两者之间有什么关系呢？</p><ul><li>对于一个bucket来说，如果当前的global depth等于local depth，那说明这个bucket只有一个指针指向它。</li><li>如果当前的global depth大于local depth，必定不止一个指针指向它。</li><li>计算当前bucket有几个指针指向它的公示是$2^{globalDepth-localDepth}$。</li></ul><p>Global depth和local depth的概念就是这些，然而在实现算法的过程中还有对这些概念的应用，我们暂且先忽略，之后的部分会一一阐述。</p><h2 id="Implementation-Scheme"><a href="#Implementation-Scheme" class="headerlink" title="Implementation Scheme"></a>Implementation Scheme</h2><p>对于Bucket的Insert，Remove以及Find操作，熟悉一下C++的list容器相关操作就可以实现。不过有一个地方需要注意的是，实现bucket的Insert方法时，注释里说的是先检查key是否存在，如果存在就要更新value。这里如果先判断bucket是否满了，就会出现bug。因为如果一个bucket满了，但刚你要插入的key在这个bucket的中，先判断是否满的话就会直接返回，不会更新对应key的value，就会造成之后find的错误。</p><p>实现了Bucket的三个操作之后，就可以实现ExtendibleHashTable的三大操作了。为了确保线程安全，每一个操作应当加锁来保证。</p><p>这里阐述一下Insert的算法流程，然后结合一个具体的例子，分析算法可能遇到的情况。</p><ol><li>尝试插入Key，若插入成功，返回即可，若不成功，执行步骤2。</li><li>判断当前<code>IndexOf(key)</code>指向的bucket下，该bucket是否满了。如果满了，执行步骤3。否则执行步骤7。</li><li>如果当前global depth等于local depth，说明bucket已满，需要增长direcotry的大小。增加directory的global depth，并将新增加的entry链接到对应的bucket。否则，继续执行步骤4。</li><li>记录当前的local mask，创建bucket1和bucket2，增加两个bucket的local depth，增加num bucket的数量。取出之前满了的bucket中的元素，按照local mask的标准将每个元素重新分配到bucket1和bucket2中。执行步骤5。</li><li>对每个链接到产生overflow的bucket的direcotry entry，按照local mask的标准，重新分配指针指向。执行步骤6。</li><li>重新计算<code>IndexOf(key)</code>，执行步骤2。</li><li>插入指定的key&#x2F;value pair。</li></ol><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>这个例子来自于官方的Homework #2 - Question 3。假定每一个bucket的容量大小为2，且哈希函数用最低的g个二进制位，g指global depth。</p><p>按顺序插入15，14，23，11，9。这几个数对应的二进制分别是，1111，1110，10111，1011，1001。</p><p><strong>STEP 1</strong>：首先插入15和14，第一步没什么问题。</p><p><img src="/2023/03/22/Extendible_Hash_Table/eht2.png"></p><p><strong>STEP 2</strong>：接着插入23，23的二进制是10111，当前的global depth是0，计算得到的<code>IndexOf(key)</code>是0，说明23要插入到directory的第0个entry中，但是这个entry所指向的bucket满了。我们执行步骤3（<em><strong>重复一下步骤3：如果当前global depth等于local depth，说明bucket已满，需要增长direcotry的大小。增加directory的global depth，并将新增加的entry链接到对应的bucket。否则，继续执行步骤4</strong></em>）。</p><p><img src="/2023/03/22/Extendible_Hash_Table/eht3.png"></p><p>这一步有一个很重要的点，新增长的entry怎么分配到对应的bucket？如果和上图的情况一样，从1增长到2，只需要把多出来的一个拉到唯一的bucket上就可以了，但如果从2到4，从4到8呢？多出来的若干个如何处理？其实只需要将多出来的一部分指针完全复制之前的一份就可以了。这样做法我觉得是可扩展哈希的比较重要的细节，由于可扩展哈希扩展direcotry时是按照当前大小的两倍进行扩展，新增长出来的部分作为之前directory的对等实体，每一个新的entry都对应了之前对应的entry，指向相同的bucket。唯一的不同就是之前的direcotry的索引最高位是0，扩展出来的最高位是1。</p><p><img src="/2023/03/22/Extendible_Hash_Table/eht4.png"></p><p><strong>STEP 3</strong>：执行步骤4（<em><strong>记录当前的local mask，创建bucket1和bucket2，增加两个bucket的local depth，增加num bucket的数量。取出之前满了的bucket中的元素，按照local mask的标准将每个元素重新分配到bucket1和bucket2中。执行步骤5</strong></em>）。</p><p>当前local mask的计算方法是<code>1 &lt;&lt; local_depth</code>，其中的local depth是指<strong>STEP 2</strong>图片中，扩展之前的local depth，即为0。</p><p>为什么呢？因为在扩展之前，产生overflow的bucket中的数据，低local depth个的二进制位完全相同，在<strong>STEP 2</strong>的图片例子中，1111和1110没有相同的低位二进制位，因此local depth是0。现在要插入23（0b10111），由于bucket已经满了，所以我们需要分裂bucket、重分配KV pair、重分配entry的指向。分裂了bucket，就产生两个bucket。</p><p>怎么放KV pair呢？我们总不能乱放吧？我们肯定要有规律的去分配。1111和1110，由于之前local depth为0，表明不需要参考任何二进制位，因此可以放到一个bucket里。当插入10111时，一个bucket放不下了，就需要两个bucket，为了可以高效的查询，当然是<strong>归类分配</strong>才行。按什么归类？当我们给事物归类的时候，我们会按属性归类，玩具为一类，家具为一类。二进制怎么归类呢？我们可以从最低位二进制位开始对比，之前不需要对比，现在我们至少需要对比一个二进制位，才能将3个二进制数分为两类（2个+1个，如果对比一个二进制位还不行，就继续增加local depth）。local mask的意思就是，之前local depth为0，不需要对比，但我现在要对比第一位，那么我就可以使用<code>1 &lt;&lt; local_depth</code>，1左移0位还是1，就是对比第一位二进制位。通过对比，1111和1110就不再是一类了，可以分别放入不同的bucket。</p><p><img src="/2023/03/22/Extendible_Hash_Table/eht5.png"></p><p><strong>STEP 4</strong>：执行步骤5（<em><strong>对每个链接到产生overflow的bucket的direcotry entry，按照local mask的标准，重新分配指针指向。执行步骤6</strong></em>）。</p><p><img src="/2023/03/22/Extendible_Hash_Table/eht6.png"></p><p><strong>STEP 5</strong>：执行步骤6，重新计算<code>IndexOf(key)</code>，由于改变了global depth，新计算的IndexOf(key)是1，最后执行步骤2，判断1指向的bucket没满，执行步骤7，插入23。</p><p><img src="/2023/03/22/Extendible_Hash_Table/eht7.png"></p><p><strong>STEP 6</strong>：接下来我们插入11（0b1011）。<strong>NOTE：这个例子在实现的过程中容易忽略掉</strong>。首先计算<code>IndexOf(key)</code>，得到结果为1，我们就要插入红色的bucket。但红色bucket满了，同时，global depth等于local depth，因此需要扩展directory，执行步骤3。</p><p><img src="/2023/03/22/Extendible_Hash_Table/eht8.png"></p><p>之前的local depth我们比较最低位的二进制位，将1111和10111放入了一个bucket，由于该bucket产生了overflow，又分裂为两个bucket，我们就需要对这个产生overflow的bucket中的元素重新归类。正常情况下，产生overflow的bucket的中的元素可以被平均的分布到两个bucket中，但这个例子中，我们对比两个数的第二位，发现1111和10111最低的第二位仍然是1，那么还是将两者化为一类。并更新与overflow的bucket相关的directory entry的指向。</p><p><img src="/2023/03/22/Extendible_Hash_Table/eht9.png"></p><p>复杂的问题又来了，之前01和11的entry都指向一个bucket，在分裂的时候，我们怎么去redirect呢？答案是利用local depth和local mask。<strong>分裂之前的local depth为1（0b01），意味着指向这个bucket的最低一位二进制位都相同</strong>。01和11两个数的最低一位二进制位都是1。我们要分裂bucket，一定是bucket已经满了，也说明当前比较二进制位最低一位在将来不适用了，因为连上要插入的数，三个数的最低一位二进制位都是1，因此我们才需要local mask，将1（0b01）左移local depth位，变为2（0b10），意味着我们需要考量第二位二进制位才能区分三个数（这里的entry、global depth还有local depth之间的关系比较难理解）。<strong>想要redirect指向同一个bucket的所有entry，我们必须遍历一次directory</strong>。但并不是暴力遍历，通过观察可以发现，01和11刚好相差一个local mask，而且01作为遍历的开始，可以通过<code>hash(key) &amp; (local_mask - 1)</code>计算得到。</p><p>为什么是<code>hash(key) &amp; (local_mask - 1)</code>呢？首先<code>hash(key)</code>可以理解为得到了key的二进制数，local mask是由local depth得到的，local depth表明的是存放在当前bucket中所有key的低位二进制位相等的个数。local mask是下一个需要检查的二进制位的位置。同时我们也知道，既然key能插入这个bucket，<strong>那么说明key和存放于这个bucket中的keys是有共同性的</strong>，这个共同性就是：<strong>低local depth位二进制数完全相同</strong>。local_mask - 1和key的二进制&amp;的结果就是在directory中，最开始的那个entry，因为这个entry的值完全等于<code>hash(key) &amp; (local_mask - 1)</code>。其余所有指向这个bucket的entry，唯一与这个最开始的不同就是：local depth + 1位是0和1的区别。就是相差local mask。</p><p>啊，好复杂，感觉没有说清楚，后续可能更新一下，如果没懂可以私信我或者评论区讨论一下。</p><p>更新<code>IndexOf(key)</code>，由于global index变为2，这时的index就是0b11，即第四个directory。进入步骤2。</p><p><strong>STEP 7</strong>：判断是否能插入蓝色bucket，很明显，bucket又满了，且global depth等于local depth。进行扩展哈希表和分裂bucket。然后分配每一个KV pair。</p><p><img src="/2023/03/22/Extendible_Hash_Table/eht10.png"></p><p>最后更新<code>IndexOf(key)</code>，结果是0b011，插入绿色的bucket。</p><p><img src="/2023/03/22/Extendible_Hash_Table/eht11.png"></p><p>之后的继续添加和扩展大同小异，重点还是理解entry index、global depth和local depth的深层含义，还有相关位运算的思想。</p><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><ul><li>第一次实现的时候并没有考虑扩展后的指针指向问题，导致程序运行时访问到了nullptr的地址，报错。实际上directory的扩展本质上就是将原来的direcotry完完整整拷贝一份，不同的只是index不同。</li><li>Grade scope做测试的时候，无论如何怎么调试都过不了ConcurrentInsertFindTest和GetNumBucketsTest，尝试着根据在线测试的输出在本地写了若干个对应的测试样例。还是没办法通过。最后阅读别人的文章才发现代码中分配元素的条件和重分配entry指针指向的条件有错误，根本原因还是没理解透彻extendible hash table中的index、global depth和local depth的内涵。以后一定要理解全部的算法内容再考虑代码实现，尤其是细节部分，de这样的bug简直是痛苦。</li><li>在算法的概述中，有涉及到循环插入的过程。在上面的例子中就是插入1011时的情况。判断一个bucket满了，分裂bucket后，将产生overflow的bucket中的元素根据local depth重新分配，结果全部都分配到一个bucket中。这时候如果还是尝试插入1011，是失败的。因此需要通过while迭代，也就是test case中的multi split test。第一次实现的时候并没有考虑到这个问题。</li></ul><p>遵守课程的条例，不公开源码，但我把自己写的相关测试样例放在下面，写的比较粗糙，因为是debug太痛苦时写的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(ExtendibleHashTableTest, InsertMultipleSplitTest) &#123;</span><br><span class="line">  <span class="keyword">auto</span> table = std::make_unique&lt;ExtendibleHashTable&lt;<span class="type">int</span>, std::string&gt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">15</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">14</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">23</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">11</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">9</span>, <span class="string">&quot;e&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">4</span>, table-&gt;<span class="built_in">GetNumBuckets</span>());</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, table-&gt;<span class="built_in">GetLocalDepth</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">2</span>, table-&gt;<span class="built_in">GetLocalDepth</span>(<span class="number">1</span>));</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">3</span>, table-&gt;<span class="built_in">GetLocalDepth</span>(<span class="number">3</span>));</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">3</span>, table-&gt;<span class="built_in">GetLocalDepth</span>(<span class="number">7</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ExtendibleHashTableTest, ConcurrentInsertFindTest) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> num_runs = <span class="number">50</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> num_threads = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run concurrent test multiple times to guarantee correctness.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> run = <span class="number">0</span>; run &lt; num_runs; run++) &#123;</span><br><span class="line">    <span class="keyword">auto</span> table = std::make_unique&lt;ExtendibleHashTable&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;(<span class="number">2</span>);</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    threads.<span class="built_in">reserve</span>(num_threads);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> tid = <span class="number">0</span>; tid &lt; num_threads; tid++) &#123;</span><br><span class="line">      threads.<span class="built_in">emplace_back</span>([tid, &amp;table]() &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        table-&gt;<span class="built_in">Insert</span>(tid, tid);</span><br><span class="line">        <span class="built_in">EXPECT_TRUE</span>(table-&gt;<span class="built_in">Find</span>(tid, val));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; i++) &#123;</span><br><span class="line">      threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(table-&gt;<span class="built_in">GetGlobalDepth</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; i++) &#123;</span><br><span class="line">      <span class="type">int</span> val;</span><br><span class="line">      <span class="built_in">EXPECT_TRUE</span>(table-&gt;<span class="built_in">Find</span>(i, val));</span><br><span class="line">      <span class="built_in">EXPECT_EQ</span>(i, val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ExtendibleHashTableTest, ConcurrentInsertFind2Test) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> num_runs = <span class="number">30</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> num_threads = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run concurrent test multiple times to guarantee correctness.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> run = <span class="number">0</span>; run &lt; num_runs; run++) &#123;</span><br><span class="line">    <span class="keyword">auto</span> table = std::make_unique&lt;ExtendibleHashTable&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;(<span class="number">2</span>);</span><br><span class="line">    std::vector&lt;std::thread&gt; threadsInsert;</span><br><span class="line">    std::vector&lt;std::thread&gt; threadsFind;</span><br><span class="line">    threadsInsert.<span class="built_in">reserve</span>(num_threads);</span><br><span class="line">    threadsFind.<span class="built_in">reserve</span>(num_threads);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> tid = <span class="number">0</span>; tid &lt; num_threads; tid++) &#123;</span><br><span class="line">      threadsInsert.<span class="built_in">emplace_back</span>([tid, &amp;table]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = tid * <span class="number">10</span>; i &lt; (tid + <span class="number">1</span>) * <span class="number">10</span>; i++) &#123;</span><br><span class="line">          table-&gt;<span class="built_in">Insert</span>(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; i++) &#123;</span><br><span class="line">      threadsInsert[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> tid = <span class="number">0</span>; tid &lt; num_threads; tid++) &#123;</span><br><span class="line">      threadsFind.<span class="built_in">emplace_back</span>([tid, &amp;table]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = tid * <span class="number">10</span>; i &lt; (tid + <span class="number">1</span>) * <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="type">int</span> val;</span><br><span class="line">          <span class="built_in">EXPECT_TRUE</span>(table-&gt;<span class="built_in">Find</span>(i, val));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; i++) &#123;</span><br><span class="line">      threadsFind[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ExtendibleHashTableTest, GetNumBucketsTest) &#123;</span><br><span class="line">  <span class="keyword">auto</span> table = std::make_unique&lt;ExtendibleHashTable&lt;<span class="type">int</span>, std::string&gt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">4</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">12</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">16</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">4</span>, table-&gt;<span class="built_in">GetNumBuckets</span>());</span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">64</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">31</span>, <span class="string">&quot;e&quot;</span>);</span><br><span class="line"></span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">10</span>, <span class="string">&quot;f&quot;</span>);</span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">51</span>, <span class="string">&quot;g&quot;</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">4</span>, table-&gt;<span class="built_in">GetNumBuckets</span>());</span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">15</span>, <span class="string">&quot;h&quot;</span>);</span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">18</span>, <span class="string">&quot;i&quot;</span>);</span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">20</span>, <span class="string">&quot;j&quot;</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">7</span>, table-&gt;<span class="built_in">GetNumBuckets</span>());</span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">7</span>, <span class="string">&quot;k&quot;</span>);</span><br><span class="line">  table-&gt;<span class="built_in">Insert</span>(<span class="number">23</span>, <span class="string">&quot;l&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">8</span>, table-&gt;<span class="built_in">GetNumBuckets</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
